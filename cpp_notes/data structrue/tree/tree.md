# 树

## 二叉树遍历
采用递归实现，调整输出语句的位置
### 1.前序遍历
    根-左-右
### 2.中序遍历
    左-根-右
### 3.后序遍历
    左-右-根
## 两种遍历能否确定唯一二叉树
    中序遍历+前序遍历或后续遍历：YES
    前序遍历+后续遍历:No
### 原理
通过前序或者后续可以确定根节点，通过根节点可以在中序遍历中取得左子树和右子树。然后从取得的左右子树中在前/后序遍历中取得根节点，以此类推确定唯一的树。

### 后序+中序确定前序代码
用DFS来构建二叉树，同时输出前序遍历结果。后序遍历总是可以确定当前树的根节点，然后利用确定的根节点在中序遍历的字符串中的位置分割出左子树和右子树。然后进行递归调用，根据先左后右继续构建，当长度为1时直接输出节点。当左/右子树不存在时停止继续递归(pos = 0,pos =b.length()-1);
```c++
void dfs(string m, string b)
{
    if(b.length() == 1)
    {
        cout << b;
    }
    else
    {
        char t = b[b.length() - 1];
        cout << t;
        int pos = m.find(t);
        if(pos > 0)
            dfs(m.substr(0, pos), b.substr(0, pos));
        if(pos <b.length()-1)
            dfs(m.substr(pos + 1), b.substr(pos, b.length()-pos-1));
    }
}
```

