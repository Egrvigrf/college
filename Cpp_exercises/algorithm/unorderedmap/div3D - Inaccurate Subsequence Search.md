Maxim 有一个由 $n$ 个整数组成的数组 $a$ 和一个由 $m$ 个整数组成的数组 $b$ （ $m \le n$ ）。

如果数组 $c$ 中的元素可以重新排列，使得其中至少有 $k$ 个元素与数组 $b$ 中的元素匹配，那么马克西姆认为长度为 $m$ 的数组 $c$ 是好数组。

例如，如果 $b = [1, 2, 3, 4]$ 和 $k = 3$ ，那么数组 $[4, 1, 2, 3]$ 和 $[2, 3, 4, 5]$ 就是好数组（它们可以按如下方式重新排列： $[1, 2, 3, 4]$ 和 $[5, 2, 3, 4]$ ），而数组 $[3, 4, 5, 6]$ 和 $[3, 4, 3, 4]$ 则不是好数组。

马克西姆希望选择长度为 $m$ 的数组 $a$ 的每个子段作为数组 $c$ 的元素。帮助 Maxim 计算有多少个数组是好的。

换句话说，求有多少个位置 $1 \le l \le n - m + 1$ 的元素 $a_l, a_{l+1}, \dots, a_{l + m - 1}$ 构成一个好数组。

## 题解
可以用unordered_map来做
unordered_map<int,int> mp;
内部是哈希实现，查询时间复杂度为O(1)
用迭代器进行遍历
```c++ 
for(auto i = mp.begin(); i != mp.end(); i++)
{
    cout<<i->first<<"->"<<i->second;
}
```
用mp1记录数组b的元素出现次数，用mp2记录a中元素出现次数，不用每次都计算它们的和。
每一次移动只要更改头和尾的改动产生的影响，改变count的值。时间复杂度降为O(n)
之前每段排序然后使用双指针计算count超时代码
```c++
    for (int i = 1; i <= n - m + 1; i++)
    {
        for (int j = i; j <= i + m - 1; j++ )
        {
            c[j - i + 1] = a[j];
        }
        sort(c + 1, c + m + 1);
        int t1 = 1;
        int t2 = 1;
        int count = 0;
        while (t1 <= m && t2 <= m)
        {
            if(c[t1] == b[t2])
            {
                t1++;
                t2++;
                count++;
            }
            else if(c[t1] < b[t2])
                t1++;
            else
                t2++;
        }
        if (count >= k)
            ans++;
    }
```